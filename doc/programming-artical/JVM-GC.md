# 概述

Java 相比 C/C++ 最显著的特点便是引入了GC机制，它解决了 C/C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题。GC 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在，这就好比，我们吃完饭后在桌上放下餐盘即走，服务员会替你收拾好这些餐盘，你不会关心服务员什么时候来收，怎么收。

# GC理论

垃圾回收收集方法，GC回收器，JVM内存区域等。

## JVM内存区域

![JVM](/img/jvm.png)

虚拟机栈：描述的是方法执行时的内存模型。线程私有，生命周期与线程相同。主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息。方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机很明确，所以这块区域**不需要进行 GC**。

本地方法栈：与虚拟机栈功能非常类似，主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务，而本地方法栈为虚拟机执行本地方法时服务的。这块区域也**不需要进行 GC**。

> 本地方法(Native Method)：简单地讲，一个Native Method就是一个java调用非java代码的接口。如一个java方法的实现由非java语言实现，比如C。

程序计数器：程序计数器的主要作用是记录线程运行时的状态，方便线程被唤醒时能从上一次被挂起时的状态继续执行，需要注意的是，程序计数器是**唯一一个**在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，所以这块区域也**不需要进行 GC**。

本地内存：即堆外内存，包含元空间和直接内存。注意到上图中 Java 8 和 Java 8 之前的 JVM 内存区域的区别了吗，在 Java 8 之前有个**永久代**的概念，主要存储类的信息，常量，静态变量，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 <u>-XX:MaxPermSize</u> 的上限，所以如果动态生成类（将类信息放入永久代）或大量地执行 **String.intern**（将字段串放入永久代中的常量区），很容易造成 OOM。所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了，也就不会进行 GC，也因此提升了性能，也就不存在由于永久代限制大小而导致的 OOM 异常了（假设总内存1G，JVM 被分配内存 100M， 理论上元空间可以分配 2G-100M = 1.9G，空间大小足够），也方便在元空间中统一管理。综上所述，在 Java 8 以后这一区域也**不需要进行 GC**。

> JDK使用DirectByteBuffer对象来表示堆外内存，同样通过GC管理堆外内存的回收。具体参考：https://www.jianshu.com/p/35cf0f348275

堆：前面几块数据区域都不进行 GC，那只剩下堆了，这里是 GC 发生的区域！对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收。

### 垃圾识别

简述JVM判断堆中的对象实例或者数据是不是需要回收。

#### 引用计数法

判断对象的引用次数，若有引用，则引用次数+1，若没有引用（引用次数为0），则此对象可以回收。

```java
// 新建对象，ref=1
String test = new String("ref=1");
// ref = 0，可回收
test = null;
```

引用计数法可能存在循环引用的问题。

```java
// new a and b, ref_a = 1, ref_b = 1;
Test a = new Test("a");
Test b = new Test("b");

// ref_a = 2, ref_b = 2;
a.instance = b;
b.instance = a;

// ref_a = 1, ref_b = 1, 对象置为null，却还是有引用次数
a = null;
b = null;
```

#### 可达性算法

现代虚拟机基本都是采用这种算法来判断对象是否存活，可达性算法的原理是以一系列叫做  **GC Root** 的对象为起点出发，引出它们指向的下一个节点，再以下个节点为起点，引出此节点指向的下一个结点。这样通过 GC Root 串成的一条线就叫引用链。直到引用链遍历完毕,如果相关对象不在任意一个以 **GC Root** 为起点的引用链中，则这些对象会被判断为「垃圾」,会被 GC 回收。

![gc-roots](/img/jvm-gcroots.jpg)

如图示，如果用可达性算法即可解决上述循环引用的问题，因为从**GC Root** 出发没有到达 a,b,所以 a，b 可回收。

这里可回收并不是代表一定被回收。对象的finalize 方法给了对象一次垂死挣扎的机会，当对象不可达（可回收）时，当发生GC时，会先判断对象是否执行了 finalize 方法，如果未执行，则会先执行 finalize 方法，我们可以在此方法里将当前对象与 GC Roots 关联，这样执行 finalize 方法之后，GC 会再次判断对象是否可达，如果不可达，则会被回收，如果可达，则不回收！

**注意：** finalize 方法只会被执行一次，如果第一次执行 finalize 方法此对象变成了可达确实不会回收，但如果对象再次被 GC，则会忽略 finalize 方法，对象会被回收！这一点切记！

那么这些 **GC Roots** 到底是什么东西呢，哪些对象可以作为 GC Root 呢，有以下几类

- 虚拟机栈（栈帧中的本地变量表）中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象

```java
public class Test {
  public static Test s;
  //方法区中常量引用的对象 s2 指向的对象并不会因为 a 指向的对象被回收而回收
  public static final Test s2 = new Test();
  public static  void main(String[] args) {
    // 虚拟机栈中的引用对象
    Test a = new Test();
    // a 是栈帧中的本地变量，当 a = null 时，由于此时 a 充当了 GC Root 的作用，a 与原来指向的实例 new Test() 断开了连接，所以对象会被回收
    a = null;
    // 方法区中类静态属性引用的对象
    Test b = new Test();
    b.s = new Test();
    // b = null 时，由于 a 原来指向的对象与GC Root(变量b) 断开了连接，所以b原来指向的对象会被回收，而由于我们给 s 赋值了变量的引用，s在此时是类静态属性引用，充当了GC Root的作用，它指向的对象依然存活
    b = null;
  }
}
```

### 垃圾回收方法

现代虚拟机一般都使用可达性算法来识别哪些数据是垃圾，识别垃圾后，针对垃圾回收的方法，有以下几种。

#### 标记清除算法

步骤很简单

1. 先根据可达性算法**标记**出相应的可回收对象（图中黄色部分）
2. 对可回收的对象进行回收

优点：操作简单，不需要做移动数据的操作

缺点：会产生比较多的内存碎片

# GC实践

GC日志、OOM场景排查、内存调试工具。

# 参考文献

https://mp.weixin.qq.com/s/_AKQs-xXDHlk84HbwKUzOw

https://mp.weixin.qq.com/s/if81us1RNSOILzL8pwj72g