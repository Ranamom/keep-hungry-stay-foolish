# 概述

Java 相比 C/C++ 最显著的特点便是引入了GC机制，它解决了 C/C++ 最令人头疼的内存管理问题，让程序员专注于程序本身，不用关心内存回收这些恼人的问题。GC 真正让程序员的生产力得到了释放，但是程序员很难感知到它的存在，这就好比，我们吃完饭后在桌上放下餐盘即走，服务员会替你收拾好这些餐盘，你不会关心服务员什么时候来收，怎么收。

# GC理论

垃圾回收收集方法，GC回收器，JVM内存区域等。

## JVM内存区域

![JVM](img/jvm.png)

虚拟机栈：描述的是方法执行时的内存模型。线程私有，生命周期与线程相同。主要保存执行方法时的局部变量表、操作数栈、动态连接和方法返回地址等信息。方法执行时入栈，方法执行完出栈，出栈就相当于清空了数据，入栈出栈的时机很明确，所以这块区域**不需要进行 GC**。

本地方法栈：与虚拟机栈功能非常类似，主要区别在于虚拟机栈为虚拟机执行 Java 方法时服务，而本地方法栈为虚拟机执行本地方法时服务的。这块区域也**不需要进行 GC**。

> 本地方法(Native Method)：简单地讲，一个Native Method就是一个java调用非java代码的接口。如一个java方法的实现由非java语言实现，比如C。

程序计数器：程序计数器的主要作用是记录线程运行时的状态，方便线程被唤醒时能从上一次被挂起时的状态继续执行，需要注意的是，程序计数器是**唯一一个**在 Java 虚拟机规范中没有规定任何 OOM 情况的区域，所以这块区域也**不需要进行 GC**。

本地内存：即堆外内存，包含元空间和直接内存。注意到上图中 Java 8 和 Java 8 之前的 JVM 内存区域的区别了吗，在 Java 8 之前有个**永久代**的概念，主要存储类的信息，常量，静态变量，即时编译器编译后代码等，这部分由于是在堆中实现的，受 GC 的管理，不过由于永久代有 <u>-XX:MaxPermSize</u> 的上限，所以如果动态生成类（将类信息放入永久代）或大量地执行 **String.intern**（将字段串放入永久代中的常量区），很容易造成 OOM。所以在 Java 8 中就把方法区的实现移到了本地内存中的元空间中，这样方法区就不受 JVM 的控制了，也就不会进行 GC，也因此提升了性能，也就不存在由于永久代限制大小而导致的 OOM 异常了（假设总内存1G，JVM 被分配内存 100M， 理论上元空间可以分配 2G-100M = 1.9G，空间大小足够），也方便在元空间中统一管理。综上所述，在 Java 8 以后这一区域也**不需要进行 GC**。

> JDK使用DirectByteBuffer对象来表示堆外内存，同样通过GC管理堆外内存的回收。具体参考：https://www.jianshu.com/p/35cf0f348275

堆：前面几块数据区域都不进行 GC，那只剩下堆了，这里是 GC 发生的区域！对象实例和数组都是在堆上分配的，GC 也主要对这两类数据进行回收。

# GC实践

GC日志、OOM场景排查、内存调试工具。

# 参考文献

https://mp.weixin.qq.com/s/_AKQs-xXDHlk84HbwKUzOw

https://mp.weixin.qq.com/s/if81us1RNSOILzL8pwj72g